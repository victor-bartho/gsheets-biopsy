# Overview
A Google Sheets Automation Script for filling biopsy report information to be used in upcoming research. This script automates the process of reading biopsy reports in PDF format, extracting key information from these reports, and appending the extracted data as new rows in a Google Sheets spreadsheet. It is designed to streamline data entry for statistical analysis and research purposes, reducing manual effort and minimizing errors.


# A Google Sheets Automation Script

## Overview
This script automates the process of reading biopsy reports in PDF format, extracting key information from these reports, and appending the extracted data as new rows in a Google Sheets spreadsheet. It is designed to streamline data entry for research purposes, reducing manual effort and minimizing errors.

---

## Basic Functionality
- **Input**:
  - A directory containing biopsy report PDFs;
  - Credentials json for Google API workflow;
  - Spreadsheets Id;
  - Sheets name; 
  - Cells range to append data
- **Processing**: The script reads each PDF, extracts relevant information, and processes the data.
- **Output**: The extracted information is appended as a new row in a designated Google Sheets spreadsheet.

---

## Repository Structure
The repository consists of the following modules:

### 1. **script_main.py**
- The entry point for the script.
- Coordinates the overall workflow by invoking functions from other modules.
- Handles user inputs and triggers the processing of PDFs.
- Generates a log `.txt`and a `.txt` list with the file names that need manual review in case of problems
- Renames every sucessfully appended PDF file as the biopsy order number. This helps the team workflow, since they need to upload the biopsy in a Drive folder renamed as the biopsy order number. I plan to automate this as well in the future.

### 2. **pdf_reader_module.py**
- Contains a class that converts PDF text into a string format for further processing.
- Handles operations like reading PDF files from a directory and cleaning raw text.

#### **Class: PDFReaderModule**
- **Purpose**: Handles the extraction of text content from PDF files.
- **Key Methods**:
  - `constructor, getters and setters`
  - `save_content_into_string(self)`: Extracts text from the PDF and concatenates it into a single string.
  - `generate_txt_file_with_content(self, chosen_path, file_name='teste_exportação_conteúdo_laudo.txt')`: Saves the extracted text content into a `.txt` file at the specified location.

#### **Example Usage**:
```python
from pdf_reader_module import PDFReaderModule

# Initialize the module with a PDF file path
reader = PDFReaderModule("/path/to/biopsy_report.pdf")

# Extract text content
text_content = reader.save_content_into_string()
print(text_content)

# Save content to a .txt file
reader.generate_txt_file_with_content("/path/to/output/directory/", "output_file.txt")
```

### 3. **info_extractor.py**
- **Purpose**: Parses and extracts structured information from the raw text generated by the `pdf_reader_module`. 
- **Key Features**:
  - Utilizes regex patterns to identify and extract specific data fields.
  - Provides a customizable approach for handling different PDF formats using predefined patterns.
  - Calculates derived data, such as a patient's age at biopsy, from extracted fields.

#### **Class: BiopsyInfoExtractor**
- **Purpose**: Centralizes all logic for extracting and organizing biopsy report data.
- **Key Methods**:
  - constructor, getters and setters: Instantiates the object, retrieves extracted information, and updates field values as needed.
  - `from_model(cls, content_string, model)`: Creates an instance using predefined patterns based on the specified model. Nowadays the team works with only one model, but in the future there will be more to be implemented
  - `validate_biopsy(self)`: Checks the validity of the biopsy report by verifying essential fields.
  - `extract_*(self)`: Series of methods to extract individual fields (e.g., patient name, order number, biopsy material) using regular expressions.
  - `organize_information_into_sheets_api_input_format(self)`: Structures extracted data into a format compatible with the Google Sheets API.

#### **Example Usage**:
```python
from info_extractor import BiopsyInfoExtractor

# Initialize extractor with raw text and a pattern model
content = "Sample biopsy report text"
extractor = BiopsyInfoExtractor.from_model(content, "model_1")

# Extract specific fields
patient_name = extractor.get_patient_name()
order_number = extractor.get_order_number()

# Extract all available data by internally calling `extract_*()` methods. This process organizes the data and outputs it in a structured format ready for Google Sheets API requisitions.  
formatted_data = extractor.organize_information_into_sheets_api_input_format()
print(formatted_data)
```

### 4. **service_manager.py**
- **Purpose**: Manages the authentication and setup required to interact with Google Sheets.
-**Key Features**:
- Uses Google API credentials to establish a connection with the spreadsheet.
- Generates a service object, used to interact with Google API

#### **Class: ServiceManager**
- **Purpose**:
- **Key Methods**:
- constructor, getters and setters: Instantiates the object, retrieves extracted information, and updates field values as needed.
- `authenticate(self)`: Handles the authentication flow by either retrieving existing credentials or prompting the user to authenticate via OAuth2. From authentication, generates or refresh a token file from the credentials, that is used for comunication via OAuth2. Based on the documentation orientations.
- `start_services(self)`: Starts the necessary Google API services (e.g., Sheets, Drive) using the authenticated credentials. The service object is used to communicate with Google API and will be used by `sheets_manipulation.py`.
- `service_started(self, service_name, version)`: Checks whether a service has been started and initialized. If it is, returns True.

### **Example Usage**:
```python
service_manager = ServiceManager(credentials_file_path="path/to/credentials.json", 
                                 token_file_path="path/to/token.json")
service_manager.start_services()
sheets_service = service_manager.get_service('sheets', 'v4')

if service_manager.service_started('sheets', 'v4'):
    print("Google Sheets service is available")
```


### 5. **sheets_manipulation.py**
- **Purpose**:Handles operations related to Google Sheets, such as appending rows and updating data.
- **Key Features**:
- Data Manipulation: Append rows, count rows, and modify cell data.
- Formatting: Copy formatting from one row to another and manage table banding.
- Property Retrieval: Get sheet properties and formatting details.
- Service Checking: Ensures that required services are active before executing actions.

#### **Class: SheetsManipulator**
- **Purpose**:
- **Key Methods**:
- constructor, getters and setters: Instantiates the object, retrieves extracted information, and updates field values as needed.
  - Constructor method parameters are:
    - `service_manager_instance (ServiceManager)`:an instance of `ServiceManager` class to manage Google API communication;
    - `spreadsheet_id` (the id of the spreadsheet you want to manipulate. It can be found in Google Sheets URL)
- `check_service_operation(self, service_name: str) -> bool`: Checks if a given Google service (e.g., Sheets or Drive) is operational based on whether it has been started. Used for verification befores calling update methods
- `append_new_row(self, spreadsheet_id, cells_range, values, value_input_option='USER_ENTERED')`: Appends a new row of values to a specified range in the spreadsheet. Google Client API method that generates a HTTP requisition (Sheets API is REST based) using the parameters.
  - Parameters are what Sheets API documentation asks:
    - `spreadsheet_id`: The ID of the spreadsheet.
    - `cells_range`: The range in the sheet where data will be appended, using A1 notation (e.g., 'Sheet1!A1'). You can check the documentation or, if prefered, my notes on it [here](https://docs.google.com/document/d/1eoYO7KY5bW0pqIzDDfeOm01HsScvDjBauoOOcqWzJGA/edit?usp=sharing) 
    - `values`:A list of values to insert into the new row. - `value_input_option`: Option to define how input data is interpreted. Since we want to mimic all text formating, as if user was typing it manually, we choose 'USER_ENTERED'.
- `copy_table_banding_to_new_row(self, sheet_name)`: Since the team uses table banding (a GoogleSheets styling resource), we want to copy it to new row.

### **Example Usage**:
```python
#instantiate ServiceManager, call authenticate() and start_services() before this.

list_of_values_to_be_appended = info_extractor.organize_information_into_sheets_api_input_format()

sheets_manipulator = SheetsManipulator(service_manager_instance, spreadsheet_id)
sheets_manipulator.copy_table_banding_to_new_row(sheet_name)
sheets_manipulator.append_new_row(spreadsheet_id, cells_range, list_of_values_to_be_appended)
```
---

## Usage
1. Place all biopsy report PDFs into a designated directory.
2. Run `script_main.py` with appropriate configuration.
3. Ensure Google API credentials json are properly set up. The file path will be asked as input before execution
4. Ensure to have directory path containing the biopsy reports PDFs, it will be asked as input
5. Check sheet name that will be appended, which will be asked as input
6. Review the Google Sheets spreadsheet to confirm data is added as expected.
7. A logging report will be generated inside the directory, and can be send to script manager (me :p) in case of any bug.
8. If there is any biopsy report PDF that could not be successfuly appended, there will be a list with the file names. Manual insertion of these is advised.

obs.: Since the spreadsheet already exists, default settings for spreadsheet id is set. User can type 's' (sim/yes) to use it or 'n' (não/no) and insert the prefered one.

---

